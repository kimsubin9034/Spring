1.서블릿 필터
1-1. 필터
-HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 컨트롤러 -> ....

1-2. 필터 체인
-HTTP요청 -> WAS -> 필터1 -> 필터2 -> 필터3 ....
-필터는 체인으로 구성되는데 , 중간에 필터를 자유롭게 추가할 수 있다. 예를들어서 로그를 남기는 필터를
먼저 적용하고, 그 다음에 로그인 여부를 체크하는 필터를 만들 수 있다.
 

1-3. 필터 구현
-필터 인터페이스를 구현하고 등록하면 서블릿 컨테이너가 필터를 싱글톤 객체로 생성하고 관리한다.
-init(): 필터 초기화 메서드, 서블릿 컨테이너가 생성될 때 호출된다
-doFilter() : 고객의 요청이 올때마다 해당 메서드가 호출된다. 필터의 로직을 구현하면 된다.
-destory() : 필터 종료 메서드, 서블릿 컨테이너가 종료될 때 호출된다.

2. 스프링 인터셉터
2-1.
-스프링 인터셉터도 서블릿 필터와 같이 웹과 관련된 공통 관심 사항을 효과적으로 해결할 수 있는 기술이다.
-서블릿 필터가 서블릿이 제공하는 기술이라면, 스프링 인터셉터는 스프링 MVC가 제공하는 기술이다. 
-둘다 웹과 관련된 공통 관심 사항을 처리하지만, 적용되는 순서와 범위, 그리고 사용방법이 다르다.

2-2. 스프링 인터셉터 흐름
-HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 스프링 인터셉터 -> 컨트롤러
-스프링 인터셉터는 디스패처 서블릿과 컨트롤러 사이에서 컨트롤러 호출 직전에 호출 된다.
-스프링 인터셉터는 스프링 MVC가 제공하는 기능이기 때문에 결국 디스패처 서블릿 이후에 등장하게 된다. 
-스프링 MVC의 시작점이 디스패처 서블릿이라고 생각해보면 이해가 될 것이다.
-스프링 인터셉터에도 URL 패턴을 적용할 수 있는데, 서블릿 URL 패턴과는 다르고, 매우 정밀하게 설정할
수 있다.


2-3 스프링 인터셉터 체인
   HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 인터셉터1 -> 인터셉터2 -> 컨트롤러
   스프링 인터셉터는 체인으로 구성되는데, 중간에 인터셉터를 자유롭게 추가할 수 있다.
 예를 들어서 로그를 남기는 인터셉터를 먼저 적용하고, 그 다음에 로그인 여부를 체크하는 인터셉터를 만들 수 있다.



2-4. 인터셉터 인터페이스
-스프링의 인터셉터를 사용하려면 HandlerInterceptor 인터페이스를 구현하면 된다.
-서블릿 필터의 경우 단순하게 doFilter() 하나만 제공된다. 
-인터셉터는 컨트롤러 호출 전( preHandle ), 호출 후( postHandle ), 요청 완료 이후( afterCompletion )와 같이 단계적으로 잘 세분화 되어 있다.
-서블릿 필터의 경우 단순히 request , response 만 제공했지만, 인터셉터는 어떤 컨트롤러( handler )가
호출되는지 호출 정보도 받을 수 있다. 
-그리고 어떤 modelAndView 가 반환되는지 응답 정보도 받을 수 있다.


2-5.addPathPatterns("...")
-2개의 페이지에 대해 중복하여 interceptor를 쓰려면 addPathPatterns("/sub1/test1", "/sub1/test2")를 사용한다.
-addPathPatterns("/**") : 인터셉터를 적용할 URL 패턴을 지정한다
-1개의 "어떠한" 경로에 상관없이 쓰려면 addPathPatterns("/*") 를 사용한다.
-1개를 넘어서서 몇개의 어디든지의 경로에 추가하고 싶으면 addPathPatterns("/**") 


스프링 인터셉터 제한
HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 스프링 인터셉터 -> 컨트롤러 //로그인 사용자
HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 스프링 인터셉터(적절하지 않은 요청이라 판단, 컨트롤러 호출
X) // 비 로그인 사용자
인터셉터에서 적절하지 않은 요청이라고 판단하면 거기에서 끝을 낼 수도 있다.
 그래서 로그인 여부를체크하기에 딱 좋다.

스프링 인터셉터 체인
HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 인터셉터1 -> 인터셉터2 -> 컨트롤러
스프링 인터셉터는 체인으로 구성되는데, 중간에 인터셉터를 자유롭게 추가할 수 있다. 예를 들어서 로그를
남기는 인터셉터를 먼저 적용하고, 그 다음에 로그인 여부를 체크하는 인터셉터를 만들 수 있다.



3.ORM
3-1. ORM이란
-Object Relational mapping(객체 관계 매핑)
-객체는 객체대로 설계
-관계형 데이터베이스는 관계형 데이터베이스대로 설계
-ORM프레임워크가 중간에서 매핑
-대중적인 언어는 대부분 ORM기술이 존재
-우리가 일반적으로 알고있는 애플리케이션의 Class와 RDB(Relational DataBase)의 테이블을 매핑(연결)한다는 뜻이며,기술적으로는 어플리케이션의 객체를 RDB테이블에 자동으로 영속화 해주는 것이라고 보면된다.

3-2. 장점
-SQL문이 아닌 Method를 통해 DB를 조작할 수 있어, 개발자는 객체 모델을 이용하여 비지니스 로직을 구성하는 데만 집중할 수 있다.
-Query와 같이 필요한 선언문, 할당 등의 부수적인 코드가 줄어들어 각종 객체에 대한 코드를 별도로 작성하여
코드의 가독성을 높임
-객체지향적인 코드 작성이 가능하다. 오직 객체지향적 접근만 고려하면 되기 때문에 생산성 증가
-매핑하는 정보가 Class로 명시되었기 때문에 ERD를 보는 의존도를 낮출 수 있고 유지보수 및 리팩토리에 유리함
-MySQL로 데이터베이스를 사용하다가, PostgreSQL로 변환한다고 가정해보면, 새로 쿼리를 짜야하는 경우가 생기는데, 이런 경우에 ORM을 사용한다면 쿼리를 수정할 필요가 없다


3-3. 단점
-프로젝트의 규모가 크고 복잡하여 설계가 잘못된 경우,속도 저하 및 일관성을 무너뜨리는 문제점이 생길 수 있다
-학습비용 비쌈
-복잡하고 무거운 Query는 속도를 위해 별도의 튜닝이 필요하기 때문에 결국 SQL문을 써야할 수도 있다.

4.JPA
-Java Persistence API
-자바 어플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스
-자바 진영의 ORM기술 표준
-JPA가 제공하는 API를 사용하면 객체를 DB에 저장하고 관리할때,개발자가 직접 SQL을 작성하지 않아도 된다.
-JPA가 개발자 대신 적절한 SQL을 생성해서 DB에 전달하고, 객체를 자동으로 Mapping해준다
-JPA는 내부적으로 JDBC API를 활용하는데, 개발자가 직접 JDBC API를 활용하지 않는다.
-이 때,JPA를 활용하면 모든 SQL에 대해서 개발자 대신 JPA가 자동으로 해결해준다는 점에서 생산성을 크게 높인다.
-인터페이스 이기 때문에 Hibernate, OpenJPA등이 JPA를 구현함


5.데이터베이스 방언
-JPA는 특정 데이터베이스에 종속X
-페이징 : oracle rownum, MySQL limit
-가변 문자:oracle varchar2, MySQL varchar
-SQL표준을 지키지 않는 특정 데이터 베이스만의 고유한 기능
->oracle 이라고하는 사투리를 써서 쿼리를 작성하란 뜻


6.@Entity
-JPA가 관리할 객체

7. @id
-데이터베이스 PK와 매핑


